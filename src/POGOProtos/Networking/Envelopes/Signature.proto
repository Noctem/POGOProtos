syntax = "proto3";
package POGOProtos.Networking.Envelopes;

message Signature {
	message LocationFix {
		string provider = 1;           // "network", "gps", "fused"
		int64 timestamp_snapshot = 2;  // in ms since start
		float altitude = 4;            // Confirmed on android/ios
		float latitude = 13;
		float longitude = 14;
		float speed = 18;                    // iOS only (-1 for no reading available, speed in m/s)
		float course = 20;                   // iOS only (range seems to be -1 for not reading, and 0 to 360 for reading) confirmed by @marcel
		float horizontal_accuracy = 21;      // in meters, both on Android and iOS
		float vertical_accuracy = 22;        // iOS only
		ServiceStatus provider_status = 26;  // Usually 3 (possibly GPS status: 1 = no fix, 2 = acquiring/inaccurate, 3 = fix acquired)
		int64 floor = 27;                    // The floor of the building this person is on
		LocationType location_type = 28;     // Always 1 (if there is data at all)

		enum ServiceStatus {
			FAILED = 0;
			INITIALIZED = 1;
			PERMISSION_DENIED = 2;
			RUNNING = 3;
			STOPPED = 4;
			UNDEFINED = 5;
		}

		enum LocationType {
			NONE = 0;
			NORMAL_PROVIDER = 1;
			MOCK_PROVIDER = 2;
		}
	}

	// don't really care about this since we're not using it
	message AndroidGpsInfo {
		int64 time_to_fix = 1;
		repeated int32 satellites_prn = 2;
		repeated float azimuth = 3;
		repeated float elevation = 4;
		repeated float snr = 5;
		repeated bool has_almanac = 6;
		repeated bool has_ephemeris = 7;
		repeated bool used_in_fix = 8;
	}

	message SensorInfo {
		int64 timestamp_snapshot = 1;  // in ms since start
		double linear_acceleration_x = 3;
		double linear_acceleration_y = 4;
		double linear_acceleration_z = 5;
		double magnetic_field_x = 6;
		double magnetic_field_y = 7;
		double magnetic_field_z = 8;
		int32 magnetic_field_accuracy = 9;
		double attitude_pitch = 10;
		double attitude_yaw = 11;
		double attitude_roll = 12;
		double rotation_rate_x = 13;
		double rotation_rate_y = 14;
		double rotation_rate_z = 15;
		double gravity_x = 16;
		double gravity_y = 17;
		double gravity_z = 18;
		Status status = 19;

		enum Status {
			STATUS_UNK = 0;
		}
	}

	message DeviceInfo {
		string device_id = 1;  // Hex string
		string android_board_name = 2;
		string android_bootloader = 3;
		string device_brand = 4;             // On Android: product.brand
		string device_model = 5;             // On Android: product.device
		string device_model_identifier = 6;  // Android only, build.display.id
		string device_model_boot = 7;        // On Android: boot.hardware
		string hardware_manufacturer = 8;    // On Android: product.manufacturer
		string hardware_model = 9;           // On Android: product.model
		string firmware_brand = 10;          // On Android: product.name, on iOS: "iPhone OS"
		string firmware_tags = 12;           // Android only, build.tags
		string firmware_type = 13;           // On Android: build.type, on iOS instead: iOS version
		string firmware_fingerprint = 14;    // Android only, build.fingerprint
	}

	message Activity {
		int64 start_time_ms = 1;
		int32 unknown = 2;
		int32 walking = 3;
		int32 running = 4;
		int32 stationary = 5;
		int32 automotive = 6;
		int32 tilting = 7;
		int32 cycling = 8;

		Status status = 9;

		enum Status {
			STATUS_UNK = 0;
		}
	}

	// Only used in iOS - Android just sends an empty version
	message IOSDeviceInfo {
		bool bool1 = 1;
		bool bool2 = 2;
		bool bool3 = 3;
		bool bool4 = 4;
		bool bool5 = 5;
		bool bool6 = 6;
		bool bool7 = 7;
		bool bool8 = 8;
		bool bool9 = 9;
		bool bool10 = 10;
	}

	repeated bytes field1 = 1;
	int64 timestamp_since_start = 2;  // in ms
	string device_id = 3;             // nia.hardware.SignalLog.device_id
	repeated LocationFix location_fix = 4;
	repeated AndroidGpsInfo android_gps_info = 5;
	repeated Activity activities = 6;
	repeated SensorInfo sensor_info = 7;
	DeviceInfo device_info = 8;
	IOSDeviceInfo ios_device_info = 9;
	int32 location_hash1 = 10;
	bool field11 = 11;
	bool field12 = 12;
	int32 field13 = 13;
	int32 field14 = 14;
	string build_version = 15;  // nia.hardware.SignalLog.build_version
	int32 field16 = 16;
	string auth_token = 17;    // nia.hardware.SignalLog.auth_token
	string package_name = 18;  // nia.hardware.SignalLog.package_name
	bool field19 = 19;
	int32 location_hash2 = 20;
	bool field21 = 21;
	bytes session_hash = 22;           // 32 random bytes, unique per session.
	int64 timestamp = 23;              // epoch timestamp in ms
	repeated int64 request_hash = 24;  // hashes of each request message in a hashArray signed based on the auth_token or auth_info - xxhash64
	int64 version_hash = 25;
}
